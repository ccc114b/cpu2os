==> ./vm.c <==
// ==========================================================
// file: vm.c
// ==========================================================
#include "ir.h"

// --- VM 資料結構 ---
typedef struct
{
    char name[100];
    int value;
} Variable;

typedef struct
{
    Variable locals[MAX_LOCALS];
    int local_count;
    int return_address;
} StackFrame;

typedef struct
{
    char name[100];
    char params[MAX_ARGS][100];
    int param_count;
    int address;
} FunctionInfo;

typedef struct
{
    IR_Instruction code[MAX_CODE_SIZE];
    int code_size;
    StackFrame call_stack[MAX_CALL_STACK];
    int stack_pointer;
    int ip;
    int retval;
    int running;
    FunctionInfo functions[MAX_FUNCTIONS];
    int function_count;
    int labels[MAX_LABELS];
    char label_names[MAX_LABELS][20];
    int label_count;
    int arg_buffer[MAX_ARGS];
    int arg_count;
} VM;

// --- 載入器 (Loader) ---

// 從檔案載入 IR，填充 VM 的 code 和 functions
void vm_load_ir(VM *vm, const char *filename)
{
    FILE *f = fopen(filename, "r");
    if (!f)
    {
        perror("無法開啟 IR 檔案");
        exit(1);
    }

    char line[256];
    int reading_code = 0;
    while (fgets(line, sizeof(line), f))
    {
        line[strcspn(line, "\n")] = 0;
        if (strlen(line) == 0)
            continue;

        char part1[100] = {0}, part2[100] = {0}, part3[100] = {0}, part4[100] = {0};
        sscanf(line, "%s %s %s %s", part1, part2, part3, part4);

        if (strcmp(part1, "CODE_START") == 0)
        {
            reading_code = 1;
            continue;
        }

        if (!reading_code)
        { // 讀取元資訊
            if (strcmp(part1, "FUNC_INFO") == 0)
            {
                if (vm->function_count >= MAX_FUNCTIONS)
                {
                    fprintf(stderr, "載入錯誤: 函數過多\n");
                    exit(1);
                }
                FunctionInfo *info = &vm->functions[vm->function_count++];
                strcpy(info->name, part2);
                info->param_count = atoi(part3);
                const char *current_pos = strstr(line, part3) + strlen(part3);
                for (int i = 0; i < info->param_count; i++)
                {
                    int read = sscanf(current_pos, " %s", info->params[i]);
                    if (read != 1)
                    {
                        fprintf(stderr, "載入錯誤: 解析函數參數失敗\n");
                        exit(1);
                    }
                    current_pos = strstr(current_pos, info->params[i]) + strlen(info->params[i]);
                }
            }
        }
        else
        { // 讀取指令
            if (vm->code_size >= MAX_CODE_SIZE)
            {
                fprintf(stderr, "載入錯誤: 程式碼過長\n");
                exit(1);
            }
            IR_Instruction *instr = &vm->code[vm->code_size++];
            instr->opcode = string_to_opcode(part1);
            if (instr->opcode == OP_UNKNOWN)
            {
                fprintf(stderr, "載入錯誤: 未知的 opcode '%s'\n", part1);
                exit(1);
            }

            strcpy(instr->result, strcmp(part2, "_") == 0 ? "" : part2);
            strcpy(instr->arg1, strcmp(part3, "_") == 0 ? "" : part3);
            strcpy(instr->arg2, strcmp(part4, "_") == 0 ? "" : part4);
        }
    }
    fclose(f);
}

// --- VM 執行引擎 ---

// 在目前堆疊幀中尋找變數，找不到則報錯
int get_var(VM *vm, const char *name)
{
    StackFrame *current_frame = &vm->call_stack[vm->stack_pointer];
    for (int i = current_frame->local_count - 1; i >= 0; i--)
    {
        if (strcmp(current_frame->locals[i].name, name) == 0)
        {
            return current_frame->locals[i].value;
        }
    }
    fprintf(stderr, "VM 執行錯誤: 在目前作用域找不到變數 '%s'\n", name);
    vm->running = 0;
    return 0; // Return dummy value
}

// 在目前堆疊幀中設定變數，若不存在則建立
void set_var(VM *vm, const char *name, int value)
{
    StackFrame *current_frame = &vm->call_stack[vm->stack_pointer];
    for (int i = 0; i < current_frame->local_count; i++)
    {
        if (strcmp(current_frame->locals[i].name, name) == 0)
        {
            current_frame->locals[i].value = value;
            return;
        }
    }
    if (current_frame->local_count >= MAX_LOCALS)
    {
        fprintf(stderr, "VM 執行錯誤: 區域變數過多\n");
        vm->running = 0;
        return;
    }
    strcpy(current_frame->locals[current_frame->local_count].name, name);
    current_frame->locals[current_frame->local_count].value = value;
    current_frame->local_count++;
}

int find_label_addr(VM *vm, const char *name)
{
    for (int i = 0; i < vm->label_count; i++)
    {
        if (strcmp(vm->label_names[i], name) == 0)
            return vm->labels[i];
    }
    return -1;
}

FunctionInfo *find_function_info(VM *vm, const char *name)
{
    for (int i = 0; i < vm->function_count; i++)
    {
        if (strcmp(vm->functions[i].name, name) == 0)
            return &vm->functions[i];
    }
    return NULL;
}

void vm_init(VM *vm)
{
    vm->ip = 0;
    vm->stack_pointer = -1;
    vm->running = 1;
    vm->label_count = 0;

    // Pre-scan to map labels and function addresses
    for (int i = 0; i < vm->code_size; i++)
    {
        if (vm->code[i].opcode == OP_LABEL)
        {
            if (vm->label_count >= MAX_LABELS)
            {
                fprintf(stderr, "VM 初始化錯誤: 標籤過多\n");
                exit(1);
            }
            strcpy(vm->label_names[vm->label_count], vm->code[i].result);
            vm->labels[vm->label_count] = i;
            vm->label_count++;
        }
        else if (vm->code[i].opcode == OP_FUNC_BEGIN)
        {
            FunctionInfo *info = find_function_info(vm, vm->code[i].result);
            if (info)
            {
                info->address = i;
            }
            else
            {
                fprintf(stderr, "VM 初始化錯誤: IR 包含未在元資訊中定義的函數 '%s'\n", vm->code[i].result);
                exit(1);
            }
        }
    }
}

void vm_run(VM *vm)
{
    FunctionInfo *main_func = find_function_info(vm, "main");
    if (!main_func)
    {
        fprintf(stderr, "VM 錯誤: 找不到 main 函數\n");
        return;
    }
    if (main_func->address < 0)
    {
        fprintf(stderr, "VM 錯誤: main 函數地址未初始化\n");
        return;
    }

    vm->stack_pointer = 0;
    vm->call_stack[0].local_count = 0;
    vm->call_stack[0].return_address = -1;
    vm->ip = main_func->address;

    while (vm->running && vm->ip < vm->code_size)
    {
        IR_Instruction instr = vm->code[vm->ip];
        vm->ip++;

        switch (instr.opcode)
        {
        case OP_LOAD_CONST:
            set_var(vm, instr.result, atoi(instr.arg1));
            break;
        case OP_LOAD_VAR:
            set_var(vm, instr.result, get_var(vm, instr.arg1));
            break;
        case OP_STORE_VAR:
            set_var(vm, instr.result, get_var(vm, instr.arg1));
            break;
        case OP_ADD:
            set_var(vm, instr.result, get_var(vm, instr.arg1) + get_var(vm, instr.arg2));
            break;
        case OP_SUB:
            set_var(vm, instr.result, get_var(vm, instr.arg1) - get_var(vm, instr.arg2));
            break;
        case OP_MUL:
            set_var(vm, instr.result, get_var(vm, instr.arg1) * get_var(vm, instr.arg2));
            break;
        case OP_DIV:
            set_var(vm, instr.result, get_var(vm, instr.arg1) / get_var(vm, instr.arg2));
            break;
        case OP_EQ:
            set_var(vm, instr.result, get_var(vm, instr.arg1) == get_var(vm, instr.arg2));
            break;

        case OP_LABEL:
        case OP_FUNC_BEGIN:
        case OP_FUNC_END:
            break;

        case OP_ARG:
            if (vm->arg_count >= MAX_ARGS)
            {
                fprintf(stderr, "VM 錯誤: 參數過多\n");
                vm->running = 0;
                break;
            }
            vm->arg_buffer[vm->arg_count++] = get_var(vm, instr.arg1);
            break;
        case OP_CALL:
        {
            FunctionInfo *func_info = find_function_info(vm, instr.arg1);
            if (!func_info)
            {
                fprintf(stderr, "VM 錯誤: 呼叫未定義的函數 %s\n", instr.arg1);
                vm->running = 0;
                break;
            }
            if (vm->stack_pointer + 1 >= MAX_CALL_STACK)
            {
                fprintf(stderr, "VM 錯誤: 呼叫堆疊溢位\n");
                vm->running = 0;
                break;
            }

            vm->stack_pointer++;
            StackFrame *new_frame = &vm->call_stack[vm->stack_pointer];
            new_frame->return_address = vm->ip;
            new_frame->local_count = 0;

            for (int i = 0; i < func_info->param_count; i++)
            {
                set_var(vm, func_info->params[i], vm->arg_buffer[i]);
            }
            vm->arg_count = 0;
            vm->ip = func_info->address;
            break;
        }
        case OP_RETURN:
        {
            if (strlen(instr.arg1) > 0)
                vm->retval = get_var(vm, instr.arg1);

            int return_addr = vm->call_stack[vm->stack_pointer].return_address;
            vm->stack_pointer--;

            if (vm->stack_pointer < -1 || return_addr == -1)
            {
                vm->running = 0; // End of program
            }
            else
            {
                vm->ip = return_addr;
            }
            break;
        }
        case OP_GET_RETVAL:
            set_var(vm, instr.result, vm->retval);
            break;

        case OP_GOTO:
        {
            int target_addr = find_label_addr(vm, instr.result);
            if (target_addr != -1)
            {
                vm->ip = target_addr; // Set IP to the label's address
            }
            else
            {
                fprintf(stderr, "VM 執行錯誤: 找不到標籤 '%s'\n", instr.result);
                vm->running = 0;
            }
            break;
        }
        case OP_IF_FALSE_GOTO:
        {
            int cond_val = get_var(vm, instr.arg1);
            if (cond_val == 0)
            { // Condition is false
                int target_addr = find_label_addr(vm, instr.arg2);
                if (target_addr != -1)
                {
                    vm->ip = target_addr; // Jump
                }
                else
                {
                    fprintf(stderr, "VM 執行錯誤: 找不到標籤 '%s'\n", instr.arg2);
                    vm->running = 0;
                }
            }
            // If condition is true, do nothing and continue to the next instruction
            break;
        }
        default:
            fprintf(stderr, "VM 錯誤: 在位址 %d 遇到未知的指令 %d\n", vm->ip - 1, instr.opcode);
            vm->running = 0;
            break;
        }
    }
}

// --- 主程式 ---
int main(int argc, char *argv[])
{
    if (argc < 2)
    {
        fprintf(stderr, "用法: %s <ir_file>\n", argv[0]);
        return 1;
    }

    // 1. 初始化 VM 並從檔案載入 bytecode
    VM vm = {0}; // Initialize all fields to zero
    printf("--- 虛擬機執行階段 ---\n");
    printf("從 '%s' 載入中間碼...\n", argv[1]);
    vm_load_ir(&vm, argv[1]);

    // 2. 初始化 VM 執行環境 (掃描標籤等)
    vm_init(&vm);

    // 3. 執行
    printf("執行 bytecode...\n\n");
    vm_run(&vm);

    // 4. 輸出結果
    if (vm.running == 0 && vm.stack_pointer != -1)
    {
        printf("\n--- 執行因錯誤而中止 ---\n");
    }
    else
    {
        printf("\n--- 執行結果 ---\n");
        printf("main 函數回傳值: %d\n", vm.retval);
    }

    return 0;
}
==> ./ir2asm.c <==
// ==========================================================
// file: ir2asm.c (macOS Professional Format)
// ==========================================================
#include "ir.h"

#define MAX_VARS 50
#define MAX_TEMPS 50
/*
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

#define MAX_CODE_SIZE 1024
#define MAX_FUNCTIONS 50
#define MAX_VARS 50
#define MAX_TEMPS 50

// --- IR 定義 ---
typedef enum
{
    OP_ADD,
    OP_SUB,
    OP_MUL,
    OP_DIV,
    OP_EQ,
    OP_NE,
    OP_LT,
    OP_GT,
    OP_LOAD_CONST,
    OP_LOAD_VAR,
    OP_STORE_VAR,
    OP_GOTO,
    OP_IF_FALSE_GOTO,
    OP_LABEL,
    OP_FUNC_BEGIN,
    OP_FUNC_END,
    OP_CALL,
    OP_ARG,
    OP_RETURN,
    OP_GET_RETVAL,
    OP_UNKNOWN
} OpCode;
typedef struct
{
    OpCode opcode;
    char result[20];
    char arg1[20];
    char arg2[20];
} IR_Instruction;
*/

typedef struct
{
    char name[100];
    char params[10][100];
    int param_count;
} FunctionInfo;

// --- 狀態管理結構 ---
typedef struct
{
    char name[100];
    int offset;
} VarMap;
typedef struct
{
    char name[20];
    int reg_idx;
} TempMap;

typedef struct
{
    FunctionInfo *info;
    VarMap var_map[MAX_VARS];
    int var_count;
    TempMap temp_map[MAX_TEMPS];
    int temp_count;
    int stack_size;
} FuncContext;

FunctionInfo *find_function_info(FunctionInfo *funcs, int count, const char *name)
{
    for (int i = 0; i < count; i++)
    {
        if (strcmp(funcs[i].name, name) == 0)
            return &funcs[i];
    }
    return NULL;
}

// --- 翻譯器輔助函式 ---
int get_temp_reg(FuncContext *ctx, const char *temp_name)
{
    for (int i = 0; i < ctx->temp_count; i++)
        if (strcmp(ctx->temp_map[i].name, temp_name) == 0)
            return ctx->temp_map[i].reg_idx;
    int reg_idx = 8 + ctx->temp_count;
    strcpy(ctx->temp_map[ctx->temp_count].name, temp_name);
    ctx->temp_map[ctx->temp_count].reg_idx = reg_idx;
    ctx->temp_count++;
    return reg_idx;
}

int get_var_offset(FuncContext *ctx, const char *var_name)
{
    for (int i = 0; i < ctx->var_count; i++)
        if (strcmp(ctx->var_map[i].name, var_name) == 0)
            return ctx->var_map[i].offset;
    // New variable, allocate space on stack
    ctx->stack_size += 4;
    strcpy(ctx->var_map[ctx->var_count].name, var_name);
    ctx->var_map[ctx->var_count].offset = -ctx->stack_size;
    ctx->var_count++;
    return -ctx->stack_size;
}

void translate_function(FILE *out, FunctionInfo *func_info, IR_Instruction *all_code, int start_idx)
{
    FuncContext ctx = {0};
    ctx.info = func_info;
    int current_arg_reg = 0;
    int stack_space_for_locals = 0;

    // --- Pass 1: Scan to calculate stack size for local variables ---
    for (int i = start_idx; all_code[i].opcode != OP_FUNC_END; i++)
    {
        if (all_code[i].opcode == OP_STORE_VAR)
        {
            int is_param = 0;
            for (int p = 0; p < func_info->param_count; p++)
                if (strcmp(all_code[i].result, func_info->params[p]) == 0)
                    is_param = 1;

            int is_mapped = 0;
            for (int v = 0; v < ctx.var_count; v++)
                if (strcmp(all_code[i].result, ctx.var_map[v].name) == 0)
                    is_mapped = 1;

            if (!is_param && !is_mapped)
            {
                strcpy(ctx.var_map[ctx.var_count++].name, all_code[i].result);
                stack_space_for_locals += 4;
            }
        }
    }
    // Total stack space needed (for fp/lr + locals), must be 16-byte aligned
    int total_stack_alloc = (16 + stack_space_for_locals + 15) & -16;

    // Assign offsets to locals
    int current_local_offset = -16 - 4; // Start after saved fp/lr
    for (int i = 0; i < ctx.var_count; i++)
    {
        ctx.var_map[i].offset = current_local_offset;
        current_local_offset -= 4;
    }

    // --- Pass 2: Generate Assembly ---
    fprintf(out, "\t.globl\t_%s\t\t\t\t; -- Begin function %s\n", func_info->name, func_info->name);
    fprintf(out, "\t.p2align\t2\n");
    fprintf(out, "_%s:\t\t\t\t\t; @%s\n", func_info->name, func_info->name);
    fprintf(out, "\t.cfi_startproc\n");

    // Prologue
    fprintf(out, "\tsub\tsp, sp, #%d\n", total_stack_alloc);
    fprintf(out, "\t.cfi_def_cfa_offset %d\n", total_stack_alloc);
    fprintf(out, "\tstp\tx29, x30, [sp, #%d]\n", total_stack_alloc - 16);

    // Store parameters from registers to stack
    for (int i = 0; i < func_info->param_count; i++)
    {
        get_var_offset(&ctx, func_info->params[i]); // This will map the param
        fprintf(out, "\tstr\tw%d, [sp, #%d]\t\t; Store param '%s'\n", i, 12 - (i * 4), func_info->params[i]);
    }

    // Translate instructions
    for (int i = start_idx + 1; all_code[i].opcode != OP_FUNC_END; i++)
    {
        IR_Instruction instr = all_code[i];
        switch (instr.opcode)
        {
        case OP_LOAD_CONST:
            fprintf(out, "\tmov\tw%d, #%s\n", get_temp_reg(&ctx, instr.result), instr.arg1);
            break;
        case OP_LOAD_VAR:
            fprintf(out, "\tldr\tw%d, [sp, #%d]\t\t; Load var '%s'\n", get_temp_reg(&ctx, instr.result), get_var_offset(&ctx, instr.arg1), instr.arg1);
            break;
        case OP_STORE_VAR:
            fprintf(out, "\tstr\tw%d, [sp, #%d]\t\t; Store var '%s'\n", get_temp_reg(&ctx, instr.arg1), get_var_offset(&ctx, instr.result), instr.result);
            break;
        case OP_ADD:
            fprintf(out, "\tadd\tw%d, w%d, w%d\n", get_temp_reg(&ctx, instr.result), get_temp_reg(&ctx, instr.arg1), get_temp_reg(&ctx, instr.arg2));
            break;
        case OP_SUB:
            fprintf(out, "\tsub\tw%d, w%d, w%d\n", get_temp_reg(&ctx, instr.result), get_temp_reg(&ctx, instr.arg1), get_temp_reg(&ctx, instr.arg2));
            break;
        case OP_MUL:
            fprintf(out, "\tmul\tw%d, w%d, w%d\n", get_temp_reg(&ctx, instr.result), get_temp_reg(&ctx, instr.arg1), get_temp_reg(&ctx, instr.arg2));
            break;
        case OP_DIV:
            fprintf(out, "\tsdiv\tw%d, w%d, w%d\n", get_temp_reg(&ctx, instr.result), get_temp_reg(&ctx, instr.arg1), get_temp_reg(&ctx, instr.arg2));
            break;
        case OP_LABEL:
            fprintf(out, "%s:\n", instr.result);
            break;
        case OP_ARG:
            fprintf(out, "\tmov\tw%d, w%d\t\t\t; Set arg%d\n", current_arg_reg, get_temp_reg(&ctx, instr.arg1), current_arg_reg);
            current_arg_reg++;
            break;
        case OP_CALL:
            fprintf(out, "\tbl\t_%s\n", instr.arg1);
            current_arg_reg = 0;
            break;
        case OP_GET_RETVAL:
            fprintf(out, "\tmov\tw%d, w0\t\t\t; Get return value\n", get_temp_reg(&ctx, instr.result));
            break;
        case OP_RETURN:
            if (strlen(instr.arg1) > 0)
                fprintf(out, "\tmov\tw0, w%d\t\t\t; Set return value from %s\n", get_temp_reg(&ctx, instr.arg1), instr.arg1);
            // Epilogue
            fprintf(out, "\tldp\tx29, x30, [sp, #%d]\n", total_stack_alloc - 16);
            fprintf(out, "\tadd\tsp, sp, #%d\n", total_stack_alloc);
            fprintf(out, "\tret\n");
            break;
        default:
            break;
        }
    }
    fprintf(out, "\t.cfi_endproc\n");
    fprintf(out, "\t\t\t\t\t\t; -- End function %s\n", func_info->name);
}

// --- 主程式 ---
int main(int argc, char *argv[])
{
    if (argc < 2)
    {
        fprintf(stderr, "用法: %s <ir_file> [output_file.s]\n", argv[0]);
        return 1;
    }
    const char *input_filename = argv[1];
    const char *output_filename = (argc > 2) ? argv[2] : "output.s";

    IR_Instruction ir_code[MAX_CODE_SIZE];
    int code_size = 0;
    FunctionInfo functions[MAX_FUNCTIONS];
    int func_count = 0;

    FILE *f = fopen(input_filename, "r");
    if (!f)
    {
        perror("無法開啟 IR 檔案");
        return 1;
    }

    char line[256];
    int reading_code = 0;
    while (fgets(line, sizeof(line), f))
    {
        line[strcspn(line, "\n")] = 0;
        if (strlen(line) == 0)
            continue;
        char p1[100] = {0}, p2[100] = {0}, p3[100] = {0}, p4[100] = {0};
        sscanf(line, "%s %s %s %s", p1, p2, p3, p4);
        if (strcmp(p1, "CODE_START") == 0)
        {
            reading_code = 1;
            continue;
        }

        if (!reading_code)
        {
            if (strcmp(p1, "FUNC_INFO") == 0)
            {
                FunctionInfo *info = &functions[func_count++];
                strcpy(info->name, p2);
                info->param_count = atoi(p3);
                const char *pos = strstr(line, p3) + strlen(p3);
                for (int i = 0; i < info->param_count; i++)
                {
                    sscanf(pos, " %s", info->params[i]);
                    pos = strstr(pos, info->params[i]) + strlen(info->params[i]);
                }
            }
        }
        else
        {
            IR_Instruction *i = &ir_code[code_size++];
            i->opcode = string_to_opcode(p1);
            strcpy(i->result, strcmp(p2, "_") == 0 ? "" : p2);
            strcpy(i->arg1, strcmp(p3, "_") == 0 ? "" : p3);
            strcpy(i->arg2, strcmp(p4, "_") == 0 ? "" : p4);
        }
    }
    fclose(f);

    FILE *out = fopen(output_filename, "w");
    if (!out)
    {
        perror("無法開啟輸出檔案");
        return 1;
    }

    fprintf(out, "\t.section\t__TEXT,__text,regular,pure_instructions\n");
    fprintf(out, "\t.build_version macos, 15, 0\tsdk_version 15, 2\n");

    for (int i = 0; i < code_size; i++)
    {
        if (ir_code[i].opcode == OP_FUNC_BEGIN)
        {
            FunctionInfo *current_func_info = find_function_info(functions, func_count, ir_code[i].result);
            if (current_func_info)
            {
                translate_function(out, current_func_info, ir_code, i);
            }
        }
    }

    fprintf(out, ".subsections_via_symbols\n");
    fclose(out);
    printf("組合語言已成功寫入到 %s\n", output_filename);

    return 0;
}
==> ./compiler.c <==
// ==========================================================
// file: compiler.c (Expanded with if/while support)
// ==========================================================
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include "ir.h"

// --- Token 類型 ---
typedef enum
{
    TOKEN_EOF,
    TOKEN_ILLEGAL,
    TOKEN_INTEGER,
    TOKEN_IDENTIFIER,
    TOKEN_ASSIGN,
    TOKEN_PLUS,
    TOKEN_MINUS,
    TOKEN_MUL,
    TOKEN_DIV,
    TOKEN_EQ,
    TOKEN_NE,
    TOKEN_LT,
    TOKEN_GT,
    TOKEN_SEMI,
    TOKEN_LPAREN,
    TOKEN_RPAREN,
    TOKEN_LBRACE,
    TOKEN_RBRACE,
    TOKEN_COMMA,
    TOKEN_LET,
    TOKEN_IF,
    TOKEN_ELSE,
    TOKEN_WHILE,
    TOKEN_FN,
    TOKEN_RETURN,
} TokenType;

// --- Token 結構 ---
typedef struct
{
    TokenType type;
    char literal[100];
    int line;
    int col;
} Token;

// --- AST 節點類型 ---
typedef enum
{
    NODE_TYPE_PROGRAM,
    NODE_TYPE_NUM,
    NODE_TYPE_IDENTIFIER,
    NODE_TYPE_BIN_OP,
    NODE_TYPE_ASSIGN,
    NODE_TYPE_VAR_DECL,
    NODE_TYPE_IF,
    NODE_TYPE_WHILE,
    NODE_TYPE_BLOCK,
    NODE_TYPE_FUNC_DECL,
    NODE_TYPE_CALL,
    NODE_TYPE_RETURN,
} NodeType;

// --- AST 節點結構 ---
typedef struct ASTNode
{
    NodeType type;
    Token token;
    struct ASTNode *left;
    struct ASTNode *right;
    struct ASTNode **params;
    int param_count;
    struct ASTNode *body;
    struct ASTNode **arguments;
    int argument_count;
    struct ASTNode *condition;
    struct ASTNode *consequence;
    struct ASTNode *alternative;
    struct ASTNode **statements;
    int statement_count;
} ASTNode;

//======================================================================
// 2. 全域變數與輔助函式
//======================================================================

static IR_Instruction ir_code[1024];
static int ir_count = 0;
static int temp_count = 0;
static int label_count = 0;
typedef struct
{
    const char *input;
    size_t position, read_position;
    char ch;
    int line;
    size_t line_start_pos;
} Lexer;
typedef struct
{
    Lexer *lexer;
    Token current_token, peek_token;
} Parser;

void error(int line, int col, const char *message)
{
    fprintf(stderr, "編譯錯誤 (行 %d, 欄 %d): %s\n", line, col, message);
    exit(1);
}
char *new_temp()
{
    static char name[20];
    snprintf(name, sizeof(name), "t%d", temp_count++);
    return strdup(name);
}
char *new_label()
{
    static char name[20];
    snprintf(name, sizeof(name), "L%d", label_count++);
    return strdup(name);
}
void emit(OpCode op, const char *result, const char *arg1, const char *arg2)
{
    if (ir_count >= 1024)
        error(0, 0, "中間碼緩衝區溢位");
    ir_code[ir_count].opcode = op;
    strncpy(ir_code[ir_count].result, result ? result : "", sizeof(ir_code[0].result) - 1);
    strncpy(ir_code[ir_count].arg1, arg1 ? arg1 : "", sizeof(ir_code[0].arg1) - 1);
    strncpy(ir_code[ir_count].arg2, arg2 ? arg2 : "", sizeof(ir_code[0].arg2) - 1);
    ir_count++;
}

//======================================================================
// 3. 詞法分析器 (Lexer)
//======================================================================
void read_char(Lexer *l)
{
    if (l->ch == '\n')
    {
        l->line++;
        l->line_start_pos = l->position + 1;
    }
    if (l->read_position >= strlen(l->input))
    {
        l->ch = '\0';
    }
    else
    {
        l->ch = l->input[l->read_position];
    }
    l->position = l->read_position;
    l->read_position++;
}
Lexer *create_lexer(const char *input)
{
    Lexer *l = (Lexer *)malloc(sizeof(Lexer));
    l->input = input;
    l->position = l->read_position = l->line_start_pos = 0;
    l->line = 1;
    read_char(l);
    return l;
}
void skip_whitespace(Lexer *l)
{
    while (isspace(l->ch))
        read_char(l);
}
char peek_char(Lexer *l)
{
    if (l->read_position >= strlen(l->input))
        return '\0';
    return l->input[l->read_position];
}
Token new_token(TokenType type, const char *literal, int line, int col)
{
    Token tok;
    tok.type = type;
    strncpy(tok.literal, literal, sizeof(tok.literal) - 1);
    tok.literal[sizeof(tok.literal) - 1] = '\0';
    tok.line = line;
    tok.col = col;
    return tok;
}
Token next_token(Lexer *l)
{
    skip_whitespace(l);
    int current_col = l->position - l->line_start_pos + 1;
    int current_line = l->line;
    Token tok;
    char literal[2] = {l->ch, '\0'};
    switch (l->ch)
    {
    case '=':
        if (peek_char(l) == '=')
        {
            read_char(l);
            tok = new_token(TOKEN_EQ, "==", current_line, current_col);
        }
        else
        {
            tok = new_token(TOKEN_ASSIGN, "=", current_line, current_col);
        }
        break;
    case '!':
        if (peek_char(l) == '=')
        {
            read_char(l);
            tok = new_token(TOKEN_NE, "!=", current_line, current_col);
        }
        else
        {
            tok = new_token(TOKEN_ILLEGAL, "!", current_line, current_col);
        }
        break;
    case '+':
        tok = new_token(TOKEN_PLUS, "+", current_line, current_col);
        break;
    case '-':
        tok = new_token(TOKEN_MINUS, "-", current_line, current_col);
        break;
    case '*':
        tok = new_token(TOKEN_MUL, "*", current_line, current_col);
        break;
    case '/':
        tok = new_token(TOKEN_DIV, "/", current_line, current_col);
        break;
    case '<':
        tok = new_token(TOKEN_LT, "<", current_line, current_col);
        break;
    case '>':
        tok = new_token(TOKEN_GT, ">", current_line, current_col);
        break;
    case ';':
        tok = new_token(TOKEN_SEMI, ";", current_line, current_col);
        break;
    case '(':
        tok = new_token(TOKEN_LPAREN, "(", current_line, current_col);
        break;
    case ')':
        tok = new_token(TOKEN_RPAREN, ")", current_line, current_col);
        break;
    case '{':
        tok = new_token(TOKEN_LBRACE, "{", current_line, current_col);
        break;
    case '}':
        tok = new_token(TOKEN_RBRACE, "}", current_line, current_col);
        break;
    case ',':
        tok = new_token(TOKEN_COMMA, ",", current_line, current_col);
        break;
    case '\0':
        tok = new_token(TOKEN_EOF, "", current_line, current_col);
        break;
    default:
        if (isalpha(l->ch) || l->ch == '_')
        {
            size_t start_pos = l->position;
            while (isalnum(l->ch) || l->ch == '_')
                read_char(l);
            size_t len = l->position - start_pos;
            char ident[100];
            strncpy(ident, &l->input[start_pos], len);
            ident[len] = '\0';
            if (strcmp(ident, "let") == 0)
                return new_token(TOKEN_LET, "let", current_line, current_col);
            if (strcmp(ident, "if") == 0)
                return new_token(TOKEN_IF, "if", current_line, current_col);
            if (strcmp(ident, "else") == 0)
                return new_token(TOKEN_ELSE, "else", current_line, current_col);
            if (strcmp(ident, "while") == 0)
                return new_token(TOKEN_WHILE, "while", current_line, current_col);
            if (strcmp(ident, "fn") == 0)
                return new_token(TOKEN_FN, "fn", current_line, current_col);
            if (strcmp(ident, "return") == 0)
                return new_token(TOKEN_RETURN, "return", current_line, current_col);
            return new_token(TOKEN_IDENTIFIER, ident, current_line, current_col);
        }
        else if (isdigit(l->ch))
        {
            size_t start_pos = l->position;
            while (isdigit(l->ch))
                read_char(l);
            size_t len = l->position - start_pos;
            char num[100];
            strncpy(num, &l->input[start_pos], len);
            num[len] = '\0';
            return new_token(TOKEN_INTEGER, num, current_line, current_col);
        }
        else
        {
            tok = new_token(TOKEN_ILLEGAL, literal, current_line, current_col);
        }
    }
    if (tok.type != TOKEN_EOF)
        read_char(l);
    return tok;
}

//======================================================================
// 4. 語法分析器 (Parser) - *** 新增 IF/WHILE 解析 ***
//======================================================================
ASTNode *create_ast_node(NodeType type)
{
    ASTNode *node = (ASTNode *)calloc(1, sizeof(ASTNode));
    node->type = type;
    return node;
}
ASTNode *parse_statement(Parser *p);
ASTNode *parse_expression(Parser *p, int precedence);
ASTNode *parse_block_statement(Parser *p);
void parser_next_token(Parser *p)
{
    p->current_token = p->peek_token;
    p->peek_token = next_token(p->lexer);
}
Parser *create_parser(Lexer *l)
{
    Parser *p = (Parser *)malloc(sizeof(Parser));
    p->lexer = l;
    parser_next_token(p);
    parser_next_token(p);
    return p;
}
int get_precedence(TokenType type)
{
    switch (type)
    {
    case TOKEN_EQ:
    case TOKEN_NE:
        return 1;
    case TOKEN_LT:
    case TOKEN_GT:
        return 2;
    case TOKEN_PLUS:
    case TOKEN_MINUS:
        return 3;
    case TOKEN_MUL:
    case TOKEN_DIV:
        return 4;
    case TOKEN_LPAREN:
        return 5;
    default:
        return 0;
    }
}

ASTNode *parse_call_expression(Parser *p, ASTNode *function)
{
    ASTNode *node = create_ast_node(NODE_TYPE_CALL);
    node->token = function->token;
    node->left = function;
    node->arguments = malloc(sizeof(ASTNode *) * 10);
    node->argument_count = 0;
    if (p->peek_token.type == TOKEN_RPAREN)
    {
        parser_next_token(p);
        return node;
    }
    parser_next_token(p);
    node->arguments[node->argument_count++] = parse_expression(p, 0);
    while (p->peek_token.type == TOKEN_COMMA)
    {
        parser_next_token(p);
        parser_next_token(p);
        node->arguments[node->argument_count++] = parse_expression(p, 0);
    }
    if (p->peek_token.type != TOKEN_RPAREN)
        error(p->peek_token.line, p->peek_token.col, "函數呼叫缺少 ')'");
    parser_next_token(p);
    return node;
}

ASTNode *parse_expression(Parser *p, int precedence)
{
    ASTNode *left = NULL;
    if (p->current_token.type == TOKEN_INTEGER)
    {
        left = create_ast_node(NODE_TYPE_NUM);
        left->token = p->current_token;
    }
    else if (p->current_token.type == TOKEN_IDENTIFIER)
    {
        left = create_ast_node(NODE_TYPE_IDENTIFIER);
        left->token = p->current_token;
    }
    else if (p->current_token.type == TOKEN_LPAREN)
    {
        parser_next_token(p);
        left = parse_expression(p, 0);
        if (p->peek_token.type != TOKEN_RPAREN)
            error(p->peek_token.line, p->peek_token.col, "表達式缺少 ')'");
        parser_next_token(p);
    }
    else
    {
        error(p->current_token.line, p->current_token.col, "無效的表達式起始符號");
    }
    while (p->peek_token.type != TOKEN_SEMI && p->peek_token.type != TOKEN_RPAREN && p->peek_token.type != TOKEN_RBRACE && precedence < get_precedence(p->peek_token.type))
    {
        parser_next_token(p);
        if (p->current_token.type == TOKEN_LPAREN)
        {
            left = parse_call_expression(p, left);
        }
        else
        {
            ASTNode *infix = create_ast_node(NODE_TYPE_BIN_OP);
            infix->token = p->current_token;
            infix->left = left;
            int current_precedence = get_precedence(p->current_token.type);
            parser_next_token(p);
            infix->right = parse_expression(p, current_precedence);
            left = infix;
        }
    }
    return left;
}

ASTNode *parse_return_statement(Parser *p)
{
    ASTNode *node = create_ast_node(NODE_TYPE_RETURN);
    node->token = p->current_token;
    parser_next_token(p);
    node->left = parse_expression(p, 0);
    if (p->peek_token.type == TOKEN_SEMI)
        parser_next_token(p);
    return node;
}
ASTNode *parse_let_statement(Parser *p)
{
    ASTNode *node = create_ast_node(NODE_TYPE_VAR_DECL);
    parser_next_token(p);
    if (p->current_token.type != TOKEN_IDENTIFIER)
        error(p->current_token.line, p->current_token.col, "預期為識別碼");
    node->left = create_ast_node(NODE_TYPE_IDENTIFIER);
    node->left->token = p->current_token;
    parser_next_token(p);
    if (p->current_token.type != TOKEN_ASSIGN)
        error(p->current_token.line, p->current_token.col, "預期為 '='");
    parser_next_token(p);
    node->right = parse_expression(p, 0);
    if (p->peek_token.type == TOKEN_SEMI)
        parser_next_token(p);
    return node;
}

// ======================= NEW FUNCTION =======================

ASTNode* parse_if_statement(Parser *p) {
    ASTNode* node = create_ast_node(NODE_TYPE_IF);
    parser_next_token(p); // eat if
    if (p->current_token.type != TOKEN_LPAREN) error(p->current_token.line, p->current_token.col, "if 條件式缺少 '('");
    parser_next_token(p);
    node->condition = parse_expression(p, 0);

    // **** BUG FIX IS HERE ****
    // We must check the *peek* token, not the current one.
    if (p->peek_token.type != TOKEN_RPAREN) error(p->peek_token.line, p->peek_token.col, "if 條件式缺少 ')'");
    parser_next_token(p); // Consume expression's last token
    parser_next_token(p); // Consume ')'

    if (p->current_token.type != TOKEN_LBRACE) error(p->current_token.line, p->current_token.col, "if 主體缺少 '{'");
    node->consequence = parse_block_statement(p);
    if (p->peek_token.type == TOKEN_ELSE) {
        parser_next_token(p); // eat '}'
        parser_next_token(p); // eat 'else'
        if (p->current_token.type != TOKEN_LBRACE) error(p->current_token.line, p->current_token.col, "else 主體缺少 '{'");
        node->alternative = parse_block_statement(p);
    }
    return node;
}


ASTNode* parse_while_statement(Parser *p) {
    ASTNode* node = create_ast_node(NODE_TYPE_WHILE);
    parser_next_token(p); // eat while
    if (p->current_token.type != TOKEN_LPAREN) error(p->current_token.line, p->current_token.col, "while 條件式缺少 '('");
    parser_next_token(p);
    node->condition = parse_expression(p, 0);

    // **** BUG FIX IS HERE ****
    // We must check the *peek* token, not the current one.
    if (p->peek_token.type != TOKEN_RPAREN) error(p->peek_token.line, p->peek_token.col, "while 條件式缺少 ')'");
    parser_next_token(p); // Consume expression's last token
    parser_next_token(p); // Consume ')'

    if (p->current_token.type != TOKEN_LBRACE) error(p->current_token.line, p->current_token.col, "while 主體缺少 '{'");
    node->consequence = parse_block_statement(p);
    return node;
}

// ======================= MODIFIED FUNCTION =======================
ASTNode *parse_statement(Parser *p)
{
    switch (p->current_token.type)
    {
    case TOKEN_LET:
        return parse_let_statement(p);
    case TOKEN_RETURN:
        return parse_return_statement(p);
    case TOKEN_IF:
        return parse_if_statement(p); // NEW
    case TOKEN_WHILE:
        return parse_while_statement(p); // NEW
    case TOKEN_LBRACE:
        return parse_block_statement(p);
    default:
        error(p->current_token.line, p->current_token.col, "無效的語句起始符號");
        return NULL;
    }
}

ASTNode *parse_block_statement(Parser *p)
{
    ASTNode *block = create_ast_node(NODE_TYPE_BLOCK);
    block->statements = (ASTNode **)malloc(sizeof(ASTNode *) * 100);
    block->statement_count = 0;
    parser_next_token(p);
    while (p->current_token.type != TOKEN_RBRACE && p->current_token.type != TOKEN_EOF)
    {
        block->statements[block->statement_count++] = parse_statement(p);
        parser_next_token(p);
    }
    if (p->current_token.type != TOKEN_RBRACE)
        error(p->current_token.line, p->current_token.col, "區塊語句缺少 '}'");
    return block;
}
ASTNode *parse_function_declaration(Parser *p)
{
    ASTNode *node = create_ast_node(NODE_TYPE_FUNC_DECL);
    parser_next_token(p);
    if (p->current_token.type != TOKEN_IDENTIFIER)
        error(p->current_token.line, p->current_token.col, "函數宣告缺少名稱");
    node->left = create_ast_node(NODE_TYPE_IDENTIFIER);
    node->left->token = p->current_token;
    parser_next_token(p);
    if (p->current_token.type != TOKEN_LPAREN)
        error(p->current_token.line, p->current_token.col, "函數宣告缺少 '('");
    parser_next_token(p);
    node->params = malloc(sizeof(ASTNode *) * 10);
    node->param_count = 0;
    if (p->current_token.type != TOKEN_RPAREN)
    {
        do
        {
            if (p->current_token.type == TOKEN_COMMA)
                parser_next_token(p);
            if (p->current_token.type != TOKEN_IDENTIFIER)
                error(p->current_token.line, p->current_token.col, "預期為參數名稱");
            ASTNode *param = create_ast_node(NODE_TYPE_IDENTIFIER);
            param->token = p->current_token;
            node->params[node->param_count++] = param;
            parser_next_token(p);
        } while (p->current_token.type == TOKEN_COMMA);
    }
    if (p->current_token.type != TOKEN_RPAREN)
        error(p->current_token.line, p->current_token.col, "函數參數列表缺少 ')'");
    parser_next_token(p);
    if (p->current_token.type != TOKEN_LBRACE)
        error(p->current_token.line, p->current_token.col, "函數主體缺少 '{'");
    node->body = parse_block_statement(p);
    return node;
}
ASTNode *parse_toplevel_declaration(Parser *p)
{
    if (p->current_token.type == TOKEN_FN)
    {
        return parse_function_declaration(p);
    }
    error(p->current_token.line, p->current_token.col, "只允許在頂層宣告函數");
    return NULL;
}
ASTNode *parse_program(Parser *p)
{
    ASTNode *program = create_ast_node(NODE_TYPE_PROGRAM);
    program->statements = (ASTNode **)malloc(sizeof(ASTNode *) * 100);
    program->statement_count = 0;
    while (p->current_token.type != TOKEN_EOF)
    {
        program->statements[program->statement_count++] = parse_toplevel_declaration(p);
        parser_next_token(p);
    }
    return program;
}

//======================================================================
// 5. 中間碼生成器 (IR Generator) - *** 新增 IF/WHILE IR生成 ***
//======================================================================
typedef struct
{
    char name[100];
} Symbol;
typedef struct
{
    Symbol symbols[100];
    int count;
} SymbolTable;
SymbolTable global_symbols;
void add_global_symbol(const char *name) { strcpy(global_symbols.symbols[global_symbols.count++].name, name); }
int find_local_symbol(SymbolTable *table, const char *name)
{
    for (int i = 0; i < table->count; i++)
        if (strcmp(table->symbols[i].name, name) == 0)
            return i;
    return -1;
}
char *generate_ir(ASTNode *node, SymbolTable *local_symbols);
void generate_ir_for_function(ASTNode *node)
{
    emit(OP_FUNC_BEGIN, node->left->token.literal, NULL, NULL);
    SymbolTable local_syms = {.count = 0};
    for (int i = 0; i < node->param_count; i++)
    {
        strcpy(local_syms.symbols[local_syms.count++].name, node->params[i]->token.literal);
    }
    generate_ir(node->body, &local_syms);
    emit(OP_FUNC_END, NULL, NULL, NULL);
}

// ======================= MODIFIED FUNCTION =======================
char *generate_ir(ASTNode *node, SymbolTable *local_symbols)
{
    if (!node)
        return NULL;
    char *left_reg = NULL, *right_reg = NULL, *cond_reg = NULL;
    switch (node->type)
    {
    case NODE_TYPE_PROGRAM:
        for (int i = 0; i < node->statement_count; ++i)
        {
            add_global_symbol(node->statements[i]->left->token.literal);
        }
        for (int i = 0; i < node->statement_count; ++i)
        {
            generate_ir_for_function(node->statements[i]);
        }
        break;
    case NODE_TYPE_BLOCK:
        for (int i = 0; i < node->statement_count; ++i)
        {
            free(generate_ir(node->statements[i], local_symbols));
        }
        break;
    case NODE_TYPE_NUM:
    {
        char *temp = new_temp();
        emit(OP_LOAD_CONST, temp, node->token.literal, NULL);
        return temp;
    }
    case NODE_TYPE_IDENTIFIER:
    {
        if (find_local_symbol(local_symbols, node->token.literal) == -1)
            error(node->token.line, node->token.col, "未宣告的區域變數");
        char *temp = new_temp();
        emit(OP_LOAD_VAR, temp, node->token.literal, NULL);
        return temp;
    }
    case NODE_TYPE_VAR_DECL:
        strcpy(local_symbols->symbols[local_symbols->count++].name, node->left->token.literal);
        right_reg = generate_ir(node->right, local_symbols);
        emit(OP_STORE_VAR, node->left->token.literal, right_reg, NULL);
        free(right_reg);
        break;
    case NODE_TYPE_CALL:
    {
        for (int i = 0; i < node->argument_count; i++)
        {
            char *arg_reg = generate_ir(node->arguments[i], local_symbols);
            emit(OP_ARG, NULL, arg_reg, NULL);
            free(arg_reg);
        }
        char arg_count_str[5];
        snprintf(arg_count_str, 5, "%d", node->argument_count);
        emit(OP_CALL, NULL, node->left->token.literal, arg_count_str);
        char *result_reg = new_temp();
        emit(OP_GET_RETVAL, result_reg, NULL, NULL);
        return result_reg;
    }
    case NODE_TYPE_RETURN:
        right_reg = generate_ir(node->left, local_symbols);
        emit(OP_RETURN, NULL, right_reg, NULL);
        free(right_reg);
        break;
    case NODE_TYPE_BIN_OP:
    {
        left_reg = generate_ir(node->left, local_symbols);
        right_reg = generate_ir(node->right, local_symbols);
        char *result_reg = new_temp();
        OpCode op;
        switch (node->token.type)
        {
        case TOKEN_PLUS:
            op = OP_ADD;
            break;
        case TOKEN_MINUS:
            op = OP_SUB;
            break;
        case TOKEN_MUL:
            op = OP_MUL;
            break;
        case TOKEN_DIV:
            op = OP_DIV;
            break;
        case TOKEN_EQ:
            op = OP_EQ;
            break;
        case TOKEN_NE:
            op = OP_NE;
            break;
        case TOKEN_LT:
            op = OP_LT;
            break;
        case TOKEN_GT:
            op = OP_GT;
            break;
        default:
            error(node->token.line, node->token.col, "未知的二元運算子");
            return NULL;
        }
        emit(op, result_reg, left_reg, right_reg);
        free(left_reg);
        free(right_reg);
        return result_reg;
    }
    // ======================= NEW CASE =======================
    case NODE_TYPE_IF:
    {
        char *else_label = new_label();
        char *end_label = new_label();
        cond_reg = generate_ir(node->condition, local_symbols);
        emit(OP_IF_FALSE_GOTO, NULL, cond_reg, else_label);
        free(cond_reg);
        generate_ir(node->consequence, local_symbols);
        if (node->alternative)
        {
            emit(OP_GOTO, end_label, NULL, NULL);
        }
        emit(OP_LABEL, else_label, NULL, NULL);
        if (node->alternative)
        {
            generate_ir(node->alternative, local_symbols);
        }
        emit(OP_LABEL, end_label, NULL, NULL);
        free(else_label);
        free(end_label);
        return NULL;
    }
    // ======================= NEW CASE =======================
    case NODE_TYPE_WHILE:
    {
        char *start_label = new_label();
        char *end_label = new_label();
        emit(OP_LABEL, start_label, NULL, NULL);
        cond_reg = generate_ir(node->condition, local_symbols);
        emit(OP_IF_FALSE_GOTO, NULL, cond_reg, end_label);
        free(cond_reg);
        generate_ir(node->consequence, local_symbols);
        emit(OP_GOTO, start_label, NULL, NULL);
        emit(OP_LABEL, end_label, NULL, NULL);
        free(start_label);
        free(end_label);
        return NULL;
    }
    default:
        break;
    }
    return NULL;
}

//======================================================================
// 6. 主程式 (輸出檔案)
//======================================================================
void write_ir_to_file(FILE *f, IR_Instruction *code, int count)
{
    for (int i = 0; i < count; i++)
    {
        const char *opcode_str = opcode_to_string(code[i].opcode);
        fprintf(f, "%s %s %s %s\n", opcode_str, strlen(code[i].result) > 0 ? code[i].result : "_", strlen(code[i].arg1) > 0 ? code[i].arg1 : "_", strlen(code[i].arg2) > 0 ? code[i].arg2 : "_");
    }
}
void write_func_info_to_file(FILE *f, ASTNode *ast)
{
    for (int i = 0; i < ast->statement_count; i++)
    {
        ASTNode *func_node = ast->statements[i];
        if (func_node->type == NODE_TYPE_FUNC_DECL)
        {
            fprintf(f, "FUNC_INFO %s %d", func_node->left->token.literal, func_node->param_count);
            for (int j = 0; j < func_node->param_count; j++)
            {
                fprintf(f, " %s", func_node->params[j]->token.literal);
            }
            fprintf(f, "\n");
        }
    }
}

int main(int argc, char *argv[])
{
    if (argc != 3)
    {
        fprintf(stderr, "用法: %s <source_file> <ir_file>\n", argv[0]);
        return 1;
    }
    const char *input_filename = argv[1];
    char *source_code = NULL;
    FILE *source_file = fopen(input_filename, "r");
    if (!source_file)
    {
        perror("無法開啟來源檔案");
        return 1;
    }
    fseek(source_file, 0, SEEK_END);
    long file_size = ftell(source_file);
    rewind(source_file);
    source_code = (char *)malloc(file_size + 1);
    if (!source_code)
    {
        fprintf(stderr, "無法分配記憶體來讀取檔案\n");
        fclose(source_file);
        return 1;
    }
    size_t read_size = fread(source_code, 1, file_size, source_file);
    if ((long)read_size != file_size)
    {
        fprintf(stderr, "讀取檔案時發生錯誤\n");
        free(source_code);
        fclose(source_file);
        return 1;
    }
    source_code[file_size] = '\0';
    fclose(source_file);
    printf("--- 編譯階段 ---\n");
    printf("從檔案 '%s' 讀取原始碼...\n", input_filename);
    global_symbols.count = 0;
    Lexer *lexer = create_lexer(source_code);
    Parser *parser = create_parser(lexer);
    ASTNode *ast = parse_program(parser);
    generate_ir(ast, NULL);
    const char *output_filename = argv[2];
    FILE *out_file = fopen(output_filename, "w");
    if (!out_file)
    {
        perror("無法開啟輸出檔案");
        free(source_code);
        return 1;
    }
    write_func_info_to_file(out_file, ast);
    fprintf(out_file, "CODE_START\n");
    write_ir_to_file(out_file, ir_code, ir_count);
    fclose(out_file);
    printf("\n中間碼已成功寫入到 %s\n", output_filename);
    free(source_code);
    return 0;
}
==> ./ir.c <==
#include "ir.h"

// 將字串 op code 轉換回 enum
OpCode string_to_opcode(const char *s)
{
    if (strcmp(s, "ADD") == 0)
        return OP_ADD;
    if (strcmp(s, "SUB") == 0)
        return OP_SUB;
    if (strcmp(s, "MUL") == 0)
        return OP_MUL;
    if (strcmp(s, "DIV") == 0)
        return OP_DIV;
    if (strcmp(s, "EQ") == 0)
        return OP_EQ;
    if (strcmp(s, "NE") == 0)
        return OP_NE;
    if (strcmp(s, "LT") == 0)
        return OP_LT;
    if (strcmp(s, "GT") == 0)
        return OP_GT;
    if (strcmp(s, "LOAD_CONST") == 0)
        return OP_LOAD_CONST;
    if (strcmp(s, "LOAD_VAR") == 0)
        return OP_LOAD_VAR;
    if (strcmp(s, "STORE_VAR") == 0)
        return OP_STORE_VAR;
    if (strcmp(s, "GOTO") == 0)
        return OP_GOTO;
    if (strcmp(s, "IF_FALSE_GOTO") == 0)
        return OP_IF_FALSE_GOTO;
    if (strcmp(s, "LABEL") == 0)
        return OP_LABEL;
    if (strcmp(s, "FUNC_BEGIN") == 0)
        return OP_FUNC_BEGIN;
    if (strcmp(s, "FUNC_END") == 0)
        return OP_FUNC_END;
    if (strcmp(s, "CALL") == 0)
        return OP_CALL;
    if (strcmp(s, "ARG") == 0)
        return OP_ARG;
    if (strcmp(s, "RETURN") == 0)
        return OP_RETURN;
    if (strcmp(s, "GET_RETVAL") == 0)
        return OP_GET_RETVAL;
    return OP_UNKNOWN;
}

const char *opcode_to_string(OpCode opcode)
{
    char *opcode_str = "";
    switch (opcode)
    {
    case OP_ADD:
        opcode_str = "ADD";
        break;
    case OP_SUB:
        opcode_str = "SUB";
        break;
    case OP_MUL:
        opcode_str = "MUL";
        break;
    case OP_DIV:
        opcode_str = "DIV";
        break;
    case OP_EQ:
        opcode_str = "EQ";
        break;
    case OP_NE:
        opcode_str = "NE";
        break;
    case OP_LT:
        opcode_str = "LT";
        break;
    case OP_GT:
        opcode_str = "GT";
        break;
    case OP_LOAD_CONST:
        opcode_str = "LOAD_CONST";
        break;
    case OP_LOAD_VAR:
        opcode_str = "LOAD_VAR";
        break;
    case OP_STORE_VAR:
        opcode_str = "STORE_VAR";
        break;
    case OP_GOTO:
        opcode_str = "GOTO";
        break;
    case OP_IF_FALSE_GOTO:
        opcode_str = "IF_FALSE_GOTO";
        break;
    case OP_LABEL:
        opcode_str = "LABEL";
        break;
    case OP_FUNC_BEGIN:
        opcode_str = "FUNC_BEGIN";
        break;
    case OP_FUNC_END:
        opcode_str = "FUNC_END";
        break;
    case OP_CALL:
        opcode_str = "CALL";
        break;
    case OP_ARG:
        opcode_str = "ARG";
        break;
    case OP_RETURN:
        opcode_str = "RETURN";
        break;
    case OP_GET_RETVAL:
        opcode_str = "GET_RETVAL";
        break;
    case OP_UNKNOWN:
        opcode_str = "UNKNOWN";
        break;
    }
    return opcode_str;
}