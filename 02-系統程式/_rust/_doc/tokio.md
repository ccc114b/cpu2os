## ccc: tokio 是什麼？為何命令列的程式也要用到他

簡單來說，**Tokio 是 Rust 世界中最流行的「非同步執行環境」（Asynchronous Runtime）**。

如果你熟悉其他語言，Tokio 的角色有點像 **Node.js 的事件迴圈 (Event Loop)**，或是 **Go 語言內建的 Goroutine 調度器**。

以下拆解為什麼一個簡單的「命令列程式 (CLI)」也需要用到它：

### 1. Rust 的語言特性：有語法，但沒引擎
Rust 語言本身雖然支援 `async` 和 `await` 關鍵字，但它**內部的標準函式庫並沒有包含「如何執行這些非同步任務」的引擎**。

*   `async` 只是告訴編譯器：「這段程式碼以後會非同步執行」。
*   `Tokio` 則是那個負責在背後跑這些任務的「引擎」。

如果沒有 Tokio 這種 Runtime，你的 `async fn main()` 就無法跑起來，因為沒有人去驅動它。

### 2. 為什麼命令列程式需要「非同步」？
你可能會覺得：「我只是發一個請求給 Ollama，等它回傳就好，為什麼要搞得這麼複雜？」

主要原因有三個：

#### A. 網路請求的本質是「等待」
當你呼叫 Ollama API 時，你的電腦發出訊號後，CPU 其實有 99% 的時間都在閒置，等待網路封包傳回來。
*   **同步 (Blocking)：** 程式會卡在那裡死等，什麼都不能做。
*   **非同步 (Async)：** 程式可以利用等待的時間處理其他事（例如顯示「載入中」的動畫、處理使用者的下一個輸入、或同時呼叫多個模型）。

#### B. 函式庫的依賴（最重要的原因）
在 Rust 生態系中，最受歡迎的 HTTP 客戶端叫 `reqwest`。為了達到最高效能，**`reqwest` 是基於非同步架構開發的**。
因為 `reqwest` 要求非同步，所以呼叫它的程式（也就是你的 CLI）也必須變成非同步。而要執行非同步，你就必須引入 `Tokio`。

#### C. 處理 LLM 的「串流輸出」(Streaming)
如果你用過 ChatGPT 或 Ollama，你會發現字是一個一個跳出來的，而不是整段一次出現。
*   這種「邊收邊讀」的功能（Streaming），在非同步環境下非常容易實現。
*   如果是同步環境，程式會非常難以同時處理「接收網路數據」與「立即顯示到螢幕上」這兩件事。

### 3. 命令列程式用 Tokio 的好處
即使是小工具，用 Tokio 也有這些優勢：
1.  **效能極高：** Tokio 處理 I/O 的效率非常驚人，資源佔用極低。
2.  **生態系完整：** 幾乎所有 Rust 的網路、資料庫、檔案監控函式庫都是為 Tokio 設計的。
3.  **並行能力：** 如果你想要同時問 Ollama 三個問題，Tokio 可以讓你用幾行程式碼就達成「同時發送、同時等待、誰先好誰先出」的功能。

### 總結
在 Rust 中，看到 `#[tokio::main]` 就代表：**「這是一個會涉及網路或大量 I/O 的程式，我需要 Tokio 幫我管理這些非同步任務。」**

對於呼叫 Ollama API 這種網路作業，Tokio 雖然增加了一點點學習曲線，但它是保證程式流暢、不卡頓的最佳方案。